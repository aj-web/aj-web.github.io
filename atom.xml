<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>呢喃的博客</title>
  
  
  <link href="https://aj-web.github.io/atom.xml" rel="self"/>
  
  <link href="https://aj-web.github.io/"/>
  <updated>2021-08-31T10:56:03.121Z</updated>
  <id>https://aj-web.github.io/</id>
  
  <author>
    <name>ninan</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>特征工程基础</title>
    <link href="https://aj-web.github.io/2021/08/31/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/"/>
    <id>https://aj-web.github.io/2021/08/31/%E7%89%B9%E5%BE%81%E5%B7%A5%E7%A8%8B%E5%9F%BA%E7%A1%80/</id>
    <published>2021-08-31T08:28:55.318Z</published>
    <updated>2021-08-31T10:56:03.121Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在进行了数据收集，数据清洗，就要开始特征工程了，数据和特征决定了机器学习的上限，而模型和算法只是不断逼近这个上限而已，所以特征工程是非常重要的。这一节我们来学习特征工程。</p><span id="more"></span><h1 id="1-机器学习目标"><a href="#1-机器学习目标" class="headerlink" title="1.机器学习目标"></a>1.机器学习目标</h1><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在机器学习中，最为典型的分类算法和回归算法，他们的处理流程也是类似于这样一个过程。通过对历史数据的推断，寻找数字之间的规律，从而预测出后面的数字是什么样的。只不过，他要处理的问题，比这个简单的数字推断更复杂。机器学习的历史数据不再是一个一个的数字，而是由多个数字组成的向量。并且，数据之间的规律更难找到，同时也没有这么稳固。很可能数字之间并没有完全准确的规则，这时就需要选择出一个相对靠谱的数字来。其实这个思想跟之前的数字推断是一样的。所以总结来说机器学习处理的是数字向量之间的问题。</p><h1 id="2-机器学习标准处理流程"><a href="#2-机器学习标准处理流程" class="headerlink" title="2.机器学习标准处理流程"></a>2.机器学习标准处理流程</h1><ul><li><p>数据收集：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;机器学习会通过学习历史数据，总结出一些最有可能的规律。当这些规律达到一个比较高的可信度时，就可以用来对未来数据进行预测了。所以数据的体量以及质量，往往就决定了机器学习所能达到的高度。这也是为什么很多好的机器学习产品最先都是出在像谷歌、百度这样的大公司的，就是因为他们的数据往往是最大最全的。</p></li><li><p>2.数据清洗：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;有了数据之后还需要进行清洗。原始的数据就像是矿石，往往含金量非常低。这个时候就要通过数据清洗，将明显无用的信息去掉，并且把数据整理成能够被机器学习接收的数据格式。这个过程通常没有固定的工作方式，需要根据不同的算法不同的要求，指定不同的处理方式。数据清洗是前期工作量非常大的一个环节，同时也是非常考验程序员工程能力的环节</p></li><li><p>3.训练模型：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;这个过程是最关键的，但是其实他也是比较简单的。有了数据之后，你只需要选择一个合适的机器学习算法，把数据交给他学习，自然就会形成一个数据模型。这个过程往往不需要人工进行干预。甚至很多时候，机器学习到底学习到了哪些规律，人也是很难弄明白的。在这个过程中，需要注意的是，针对同一个问题，往往可以选择很多的算法，甚至针对同一个算法，也会需要制定不同的超参数。这些组合都会计算出不同的数据模型。所有这些模型都是可选的结果</p></li><li><p>4.模型优化：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;训练出了模型，并不能代表机器学习成功。有了众多的数据模型之后，就需要在这些模型中找出针对当前问题的最佳方案。这个优化过程即需要基于对算法的深入了解，同时也需要基于大量的尝试。也是非常考验算法工程师技术的地方。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;最常用的检测方案是将整个数据集随机拆分成训练集和测试集。用机器学习算法在训练集上学习并形成数据模型，然后拿这个数据模型对测试集的数据进行预测，接下来拿预测出来的目标值与测试集上实际的目标值进行比对。目标值真实结果匹配度最高的模型就认为是最好的模型。我们经常说的人脸识别准确率达到多少多少，其实就是在测试集上的比对结果。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;另外，从历史数据中学习形成的数据模型，最终还是要回归于对未来业务的指导，而未来业务又会形成新的数据集。这个时候模型优化一个很重要的过程就是需要让模型继续学习更多新的业务数据，及时优化。这样才能让模型的准确地更高。</p></li></ul><h1 id="3-常用的特征工程方法"><a href="#3-常用的特征工程方法" class="headerlink" title="3. 常用的特征工程方法"></a>3. 常用的特征工程方法</h1><h2 id="3-1-特征抽取"><a href="#3-1-特征抽取" class="headerlink" title="3.1 特征抽取:"></a>3.1 特征抽取:</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;机器学习只能学习数字类型的特征值，但是有些数据集他的原始数据不是数字类型，比如图像、文本、字符等。这时，就需要使用特征抽取将数据转化成适合机器学习的数字特征。</p><h3 id="3-1-1-文本特征抽取："><a href="#3-1-1-文本特征抽取：" class="headerlink" title="3.1.1 文本特征抽取："></a>3.1.1 文本特征抽取：</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;场景：现在如果我们要对文本的分类情况进行机器学习，这是一个典型的分类问题，但是这个特征值似乎跟我们之前提到的特征值不太一样。文本没有那些属性和数字啊。那应该怎么抽取特征值呢？</p><h3 id="3-1-1-one-hot编码："><a href="#3-1-1-one-hot编码：" class="headerlink" title="3.1.1 one-hot编码："></a>3.1.1 one-hot编码：</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对于字典类型的数据特征，例如 性别、城市、颜色这一类字典类型数据，通常在数据库中，会以一个数字编码标识，如 0:男,1:女 这样。但是，如果在机器学习中使用这样的数字编码，就会给学习过程造成误解。因为不同的字典值特性应该是完全“平等”，而如果是 0，1，2这样的数字，则可能给机器学习造成误解，觉得这些字典值是有大小关系的。所以，机器学习中常用的方式是把字典值处理成one-hot编码。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/one-hot%E7%BC%96%E7%A0%81.png" alt="one-hot编码"></p><h3 id="3-1-2-CountVectorize："><a href="#3-1-2-CountVectorize：" class="headerlink" title="3.1.2 CountVectorize："></a>3.1.2 CountVectorize：</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对于文本类型的数据，如一篇文章。在做机器学习时，最基础的处理方式是以文章中的单词出现次数作为特征。处理成 [(word1,count1),(word2,count2)…]这样的格式。这也是mapreduce、spark最经典的入门计算方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">缺点：在文章分类等机器学习场景中，体现不出文章的重要特征。例如一般出现次数最多的一些词，如，这里、那里、我们、他们等，并不能体现文章的内容特征。这类词称为停用词。</span><br></pre></td></tr></table></figure><h3 id="3-1-3-TfidfVectorizer："><a href="#3-1-3-TfidfVectorizer：" class="headerlink" title="3.1.3 TfidfVectorizer："></a>3.1.3 TfidfVectorizer：</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;我们的目的是为了对文本进行分类，但是简单的以单词出现的次数来分类，从经验上判断，会有些问题。长的文章中各个词出现的次数都会比较多，而短的文章各个词普遍都会比较少。这样长的文章对分类结果的影响就会被放大。这时改进的办法就是TF-IDF<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;TF-IDF可以用来评估一个字词对于一个文件集合或者一个语料库中的其中一份文件的重要程度。例如，在对一大堆文章进行分类时，出现 计算机、软件、云、java这些词的次数比较多的文章更多可能归为科技类(在其他类中出现就比较少，这样的词才有重要性)，而出现 银行、信贷、信用卡 这类词出现次数较多的文章更多可能归为金融类。而所有文章中出现次数都比较多的 我们、你们、这里、那里等这一类的词则对分类来说，意义不大。</p><p>TF-IDF由TF和IDF两部分组成:<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;TF：词频 term frequency。某一个给定的词语在文章中出现的评率<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;IDF：逆向文档评率 inverse document frequency.是一个词语普遍重要性的度量。 为总文件数目 除以 包含该词语的文件的数量，再取 10为底对数。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;最终TF-IDF=TF*IDF</p><p>示例： 关键词：“经济”；语料库： 1000篇文章；10篇文章出现“经济”。</p><p>TF(经济) = 10/1000 = 0.01 ；IDF(经济)=lg(1000/10)=2</p><p>最终 TF-IDF(经济) = TF(经济)*IDF(经济) = 0.02</p><h2 id="3-2-特征预处理"><a href="#3-2-特征预处理" class="headerlink" title="3.2 特征预处理"></a>3.2 特征预处理</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;现在我们考虑这样一组特征值： 用户年龄和用户收入。我们能发现，年龄的数字相比收入的数字会小很多。根据之前特征要平等的原则，直觉上就会觉得，这一组数据集中，用户收入的特征会被放大，而用户年龄的特征就容易被忽略。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E7%89%B9%E5%BE%81%E5%80%BC%E5%BD%92%E4%B8%80%E5%8C%96.png" alt="归一化"></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;你可能会想，这组数据，我把用户收入除100，是不是也就把收入固定到了0~100的范围，跟年龄差不多？这确实也是一种处理办法，但是，这样的处理方法，一方面，量纲的影响还是没有完全统一，范围并没有填满。另一方面，用户收入这个特征的很多信息其实就丢失了，拿去机器学习就会丢失很多特征，效果就不会太好。那业界比较常用的方式有两种，归一化 和 标准化。</p><h3 id="3-2-1-归一化"><a href="#3-2-1-归一化" class="headerlink" title="3.2.1 归一化"></a>3.2.1 归一化</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;归一化通过对原始数据进行变换把数据映射到[0,1]这样一个标准区间。而这个标准区间是可以根据实际情况调整的。<br>他的标准计算公式如下：<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%BD%92%E4%B8%80%E5%8C%96%E6%96%B9%E7%A8%8B.png" alt="归一化方程"></p><pre><code>其中max,min分别表示这一列特征值中的最大值和最小值。 而mx,mi表示指定的映射区间。默认mx为1，mi为0。归一化的缺点：对异常值敏感。当数据集中出现一个不太合理的极大值或者极小值时，整个归一化的结果就非常不好。鲁棒性(稳定性)较差</code></pre><h3 id="3-2-2-标准化"><a href="#3-2-2-标准化" class="headerlink" title="3.2.2 标准化"></a>3.2.2 标准化</h3><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上面提到，归一化对异常值是非常敏感的。而标准化就能很好的处理这种异常数据的问题。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;标准化是通过对原始数据进行变换，把数据变换到均值为0，标准差为1的范围内。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;他的计算公式是：x’= (x-mean)/std<br>mean： 特征值的均值， std：标准差。 均方差。<br>这种方式，对于极大或极小的少量异常点，均值和标准差都会比较稳定，所以异常值的影响就变小了。</p><h2 id="3-3-降维"><a href="#3-3-降维" class="headerlink" title="3.3 降维"></a>3.3 降维</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;降维是指在某些限定条件下，降低特征的个数，得到一组”不相关”的主变量的过程。那什么叫”不相关”呢？我们先简单的理解下什么叫特征与特征相关。例如，我们需要去学习某一个地区的降雨量，就会去统计一些常用的天气特征。而这其中，相对湿度与降雨量就是一个相关的特征，相对湿度大，肯定降雨量就会偏大。在进行机器学习训练算法时，如果特征本身存在问题或者特征之间相关性较强，那对于算法学习预测的影响就会比较大。而我们将为的过程，不光是要降低特征值的个数，同时也要尽量去除不相关的特征。</p><h3 id="3-3-1-主特征选择"><a href="#3-3-1-主特征选择" class="headerlink" title="3.3.1 主特征选择"></a>3.3.1 主特征选择</h3><ul><li>方差选择法： 过滤低方差特征(过于集中的数据)  </li><li>相关系数法：特征与特征之间的相关程度。例如 天气湿度 与 降雨量 一般就认为是相关性很强的特征。</li></ul><h3 id="3-3-2-主成分分析"><a href="#3-3-2-主成分分析" class="headerlink" title="3.3.2 主成分分析"></a>3.3.2 主成分分析</h3><ul><li>一种将高维数据转换为低维数据的方法。保留对目标值结果影响较大的特征值，去掉相对影响较小的特征值，例如拍照，三维空间中的人存储在二维的照片中</li><li>简单的理解就是特征个数太多，不好分析时，就可以用PCA来减少特征个数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;在进行了数据收集，数据清洗，就要开始特征工程了，数据和特征决定了机器学习的上限，而模型和算法只是不断逼近这个上限而已，所以特征工程是非常重要的。这一节我们来学习特征工程。&lt;/p&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="https://aj-web.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>对象内存机制分配</title>
    <link href="https://aj-web.github.io/2021/08/26/JVM%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E9%85%8D/"/>
    <id>https://aj-web.github.io/2021/08/26/JVM%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E6%9C%BA%E5%88%B6%E5%88%86%E9%85%8D/</id>
    <published>2021-08-26T01:54:41.570Z</published>
    <updated>2021-08-26T01:54:41.570Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>前言：思考一个问题，对象是如何创建的，对象创建的过程是怎样的？ 详情请看对象内存机制分配详解    </p></blockquote><span id="more"></span><h1 id="1-对象的创建总流程"><a href="#1-对象的创建总流程" class="headerlink" title="1. 对象的创建总流程"></a>1. 对象的创建总流程</h1><p>直接上我整理的图，按照这个图的顺序来讲解对象创建的流程<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%AF%B9%E8%B1%A1%E5%88%9B%E5%BB%BA.png" alt="对象创建"></p><h4 id="1-1-类加载检查"><a href="#1-1-类加载检查" class="headerlink" title="1.1 类加载检查"></a>1.1 类加载检查</h4><p>虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。<br>new指令对应到语言层面上讲是，new关键词、对象克隆、对象序列化等。</p><h4 id="1-2-分配内存"><a href="#1-2-分配内存" class="headerlink" title="1.2 分配内存"></a>1.2 分配内存</h4><p>(1)指针碰撞”（Bump the Pointer）：如果内存规整那么指针左边存放已经分配的内存，右边存放未分配的内粗你，指针移动一段等于对象大小的距离<br>(2)空闲列表”（Free List）：如果内存不规整，就需要有一个列表记录哪些内存可用,为什么会出现空闲列表的情况，垃圾回收中的标记清除<br>(3)多线程中，多个对象分配内存，如何确保每个对象都成功分配内存：<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/TLAB.png" alt="TLAB"><br>3.1:CAS（compare and swap）虚拟机采用CAS配上失败重试的方式保证更新操作的原子性来对分配内存空间的动作进行同步处理。<br>3.2:本地线程分配缓冲（Thread Local Allocation Buffer,TLAB），把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存。通过­XX:+/­-UseTLAB参数来设定虚拟机是否使用TLAB(JVM会默认开启­XX:+UseTLAB)，­XX:TLABSize 指定TLAB大小，默认大小为Eden的1%  </p><h4 id="1-3-初始化零值"><a href="#1-3-初始化零值" class="headerlink" title="1.3 初始化零值"></a>1.3 初始化零值</h4><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头）， 如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型    所对应的零值。</p><h4 id="1-4-设置对象头"><a href="#1-4-设置对象头" class="headerlink" title="1.4 设置对象头"></a>1.4 设置对象头</h4><p>对象在内存中存储的布局可以分为3块区域：对象头（Header）、 实例数据（Instance Data）和对齐填充（Padding），对象头详细如下<br>Mark Word：不同状态的对线头不一样，一般有对象的hashcode(25位)，分代年龄(4位),是否偏向头，锁标志位<br>Klass Points：开启指针压缩时占4个字节，关闭指针压缩时占8个字节<br>数组长度：当对象为数组的时候才有<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%AF%B9%E8%B1%A1%E5%A4%B4.png" alt="对象头"></p><h4 id="1-5-执行init方法"><a href="#1-5-执行init方法" class="headerlink" title="1.5 执行init方法"></a>1.5 执行init方法</h4><p>init方法是C++语言实现的，执行<init>方法，即对象按照程序员的意愿进行初始化。对应到语言层面上讲，<br>就是为属性赋值（注意，这与上面的赋零值不同，这是由程序员赋的值），和执行构造方法。   </p><h4 id="1-6-什么是指针压缩"><a href="#1-6-什么是指针压缩" class="headerlink" title="1.6 什么是指针压缩"></a>1.6 什么是指针压缩</h4><p>java对象的指针压缩？<br>1.在64位平台的HotSpot中使用32位指针(实际存储用64位)，内存使用会多出1.5倍左右，使用较大指针在主内存和缓存之间移动数据，占用较大宽带，同时GC也会承受较大压力<br>2.为了减少64位平台下内存的消耗，启用指针压缩功能<br>3.在jvm中，32位地址最大支持4G内存(2的32次方)，可以通过对对象指针的存入堆内存时压缩编码、取出到cpu寄存器后解码方式进行优化(对象指针在堆中是32位，在寄存器中是35位，2的35次方=32G)，使得jvm只用32位地址就可以支持更大的内存配置(小于等于32G)<br>4.堆内存小于4G时，不需要启用指针压缩，jvm会直接去除高32位地址，即使用低虚拟地址空间<br>5.堆内存大于32G时，压缩指针会失效，会强制使用64位(即8字节)来对java对象寻址，这就会出现1的问题，所以堆内存不要大于32G为好</p><h4 id="1-7-对齐填充："><a href="#1-7-对齐填充：" class="headerlink" title="1.7 对齐填充："></a>1.7 对齐填充：</h4><p>对于大部分处理器，对象以8字节整数倍来对齐填充都是最高效的存取方式</p><h1 id="2-对象内存分配"><a href="#2-对象内存分配" class="headerlink" title="2. 对象内存分配"></a>2. 对象内存分配</h1><p>上面我们讲了对象分配的方式，接着我们来介绍下对象具体如何分配的   </p><h4 id="2-1"><a href="#2-1" class="headerlink" title="2.1"></a>2.1</h4><ol><li>new一个对象时，会通过逃逸分析先判断对象能否分配在栈上，JVM通过逃逸分析确定该对象不会被外部访问。如果不会逃逸可以将该对象在栈上分配内存，这样可以减轻垃圾回收的压力<br>在栈上创建对象的时候，还会通过标量替换，来优化  </li></ol><ul><li>对象逃逸分析：就是分析对象动态作用域，当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中。说白了就是判断这个对象是否只在一个方法中被使用</li><li>标量替换：通过逃逸分析确定该对象不会被外部访问，并且对象可以被进一步分解时，JVM不会创建该对象，而是将该对象成员变量分解若干个被这个方法使用的成员变量所代替，这些代替的成员变量在栈帧或寄存器上分配空间，这样就不会因为没有一大块连续空间导致对象内存不够分配</li><li>标量与聚合量：标量即不可被进一步分解的量，而JAVA的基本数据类型就是标量（如：int，long等基本数据类型以及reference类型等），标量的对立就是可以被进一步分解的量，而这种量称之为聚合量。而在JAVA中对象就是可以被进一步分解的聚合量。结论：栈上分配依赖于逃逸分析和标量替换   </li></ul><ol start="2"><li>能在栈上分配，则在栈上分配，否则在堆上进行分配   </li><li>在堆上进行分配时：对象优先分配在Eden区,如果是大对象(字符串，数组)，大对象大小在这个参数只在 Serial 和ParNew两个收集器下可以设置，会直接放进老年代   </li><li>不是大对象，会判断Eden区能否放下，不能的话，会执行minor GC，执行完还不能就会直接放入老年代   </li><li>不是大对象则会采用TLAB在堆中预先分配内存，或者直接分配，多线程可能CAS分配 </li></ol><h4 id="2-2-对象动态年龄判断"><a href="#2-2-对象动态年龄判断" class="headerlink" title="2.2 对象动态年龄判断"></a>2.2 对象动态年龄判断</h4><p>对象动态年龄判断机制一般是在minor gc之后触发的。当前存放对象的Survivor区中，一批对象的总大小大于Survivor区域内存大小的50%(-XX:TargetSurvivorRatio可以指定年龄最大值)，那么此时大于等于这批对象年龄最大值的对象，就可以直接进入老年代了。这个规则其实是希望那些可能是长期存活的对象，尽早进入老年代。</p><h4 id="2-3-老年代空间分配担保机制"><a href="#2-3-老年代空间分配担保机制" class="headerlink" title="2.3 老年代空间分配担保机制"></a>2.3 老年代空间分配担保机制</h4><p>年轻代每次minor GC之前都会判断如果老年代的可用空间小于年轻代里面所有对象的大小之和，就会看一个-XX:-HandlePromotionFailure”(jdk1.8默认就设置了)是否设置，如果有就会看历史minor GC之后进入老年代对象的平均大小是否小于老年代的可用内存，如果小于，代表执行minor GC即可，如果大于则执行full GC，没有设置参数则直接执行full GC，如果经过以上操作，对象不能全放进老年带，则OOM错误</p><h1 id="3-对象内存回收"><a href="#3-对象内存回收" class="headerlink" title="3. 对象内存回收"></a>3. 对象内存回收</h1><h4 id="3-1-引用计数法"><a href="#3-1-引用计数法" class="headerlink" title="3.1 引用计数法"></a>3.1 引用计数法</h4><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。解决不了对象相互循环引用的问题</p><h4 id="3-2-可达性算法"><a href="#3-2-可达性算法" class="headerlink" title="3.2 可达性算法"></a>3.2 可达性算法</h4><p>将“GC Roots” 对象作为起点，从这些节点开始向下搜索引用的对象，找到的对象都标记为非垃圾对象，其余未标记的对象都是垃圾对象，<br>GC Roots根节点：线程栈的本地变量、静态变量、本地方法栈的变量等等</p><ol><li>虚拟机栈（栈帧中的本地变量表）中引用的对象</li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象</li><li>方法区中类静态属性引用的对象</li><li>方法区中常量引用的对象</li></ol><h4 id="3-3-常见引用类型"><a href="#3-3-常见引用类型" class="headerlink" title="3.3 常见引用类型"></a>3.3 常见引用类型</h4><p>java的引用类型一般分为四种：强引用、软引用、弱引用、虚引用   </p><ul><li>强引用：普通的变量引用，例如new 对象   </li><li>软应用：GC时不会被主动回收，除非GC后的内存还是不够分配对象，那么此时就会回收软引用，软引用可用来实现内存敏感的高速缓存  </li><li>弱引用：GC会直接回收  </li><li>虚引用：几乎不用  </li></ul><h1 id="4-finalize-方法最终判定对象是否存活"><a href="#4-finalize-方法最终判定对象是否存活" class="headerlink" title="4. finalize()方法最终判定对象是否存活"></a>4. finalize()方法最终判定对象是否存活</h1><p>gc后无用的对象会被标记，然后进行筛选，如果对象没有覆盖ginalize方法，那么对象被直接回收，覆盖了finalize方法后，如果方法中对象被引用或者引用别的对象，那么就不会被回收</p><h1 id="5-如何判断一个类是无用的类"><a href="#5-如何判断一个类是无用的类" class="headerlink" title="5. 如何判断一个类是无用的类"></a>5. 如何判断一个类是无用的类</h1><p>类需要同时满足下面3个条件才能算是 “无用的类” ：<br>无对象实力  classloder被回收  Class对象没有被以用</p><ol><li>该类所有的对象实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">JVM指令：</span><br><span class="line">1.本地线程分配缓冲（Thread Local Allocation Buffer,TLAB默认开启）：­XX:+/­-UseTLAB，­XX:TLABSize 指定TLAB大小</span><br><span class="line">2.指针压缩(JDK1.6默认开启):-XX:+/-UseCompressedOops(默认开启)</span><br><span class="line">3.逃逸分析(JDK1.7默认开启)：-XX:+DoEscapeAnalysis</span><br><span class="line">4.标量替换(JDK1.7默认开启)：-XX:+EliminateAllocations</span><br><span class="line">5.Eden与Survivor区占比8:1:1自动变化(默认开启):-XX:+/-UseAdaptiveSizePolicy</span><br><span class="line">6.设置大对象大小(SerialGC)：-XX:PretenureSizeThreshold=1000000 (单位是字节)  -XX:+UseSerialGC  </span><br><span class="line">7.设置分代年龄最大值:(-XX:TargetSurvivorRatio)</span><br><span class="line">8.设置空间分配担保参数：-XX:-HandlePromotionFailure</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前言：思考一个问题，对象是如何创建的，对象创建的过程是怎样的？ 详情请看对象内存机制分配详解    &lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://aj-web.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存模型深度剖析与优化</title>
    <link href="https://aj-web.github.io/2021/08/26/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/"/>
    <id>https://aj-web.github.io/2021/08/26/JVM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E6%B7%B1%E5%BA%A6%E5%89%96%E6%9E%90%E4%B8%8E%E4%BC%98%E5%8C%96/</id>
    <published>2021-08-26T01:54:41.570Z</published>
    <updated>2021-08-26T01:54:41.570Z</updated>
    
    <content type="html"><![CDATA[<hr><blockquote><p>前言：为什么要学习JVM？<br>一门语言有可能会过时，但是它的思想是不会过时的，尤其是作为JAVA跨平台的核心实现，JVM的思想值每个程序员得学习</p></blockquote><span id="more"></span><p>Java Virtual Machine(JVM) 是一种抽象的计算机，基于堆栈架构，它有自己的指令集和内存管理。它加载 class 文件，分析、解释并执行字节码。基本结构如下：<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/JVM%E6%9E%84%E6%88%90.png" alt="JVM结构"><br>JVM 主要分为以上三个子系统：类加载器、运行时数据区和执行引擎，下面我们分部分展开理解</p><h1 id="1-JVM之运行时数据区"><a href="#1-JVM之运行时数据区" class="headerlink" title="1.JVM之运行时数据区"></a>1.JVM之运行时数据区</h1><h3 id="1-1-运行时数据区组成"><a href="#1-1-运行时数据区组成" class="headerlink" title="1.1 运行时数据区组成"></a>1.1 运行时数据区组成</h3><p>它约定了在运行时程序代码的数据比如变量、参数等等的存储位置，主要包含以下几部分：   </p><ol><li>程序计数器：也是每个线程独有的，就是代码执行的位置，为什么要设计程序计数器，是为了多线程代码挂起后恢复执行</li><li>本地方法栈：与 JVM 栈类似，只不过服务于 Native 方法   </li><li>堆的组成：存储类实例对象和数组对象，垃圾回收的主要区域</li><li>栈的组成：new出来对象的引用(对象引用) ,基本数据类型和局部变量</li><li>方法区组成：又叫(元空间)，存放运行时常量池，字段和方法的数据，构造函数和方法的字节码等，在 JDK 8 中，把 interned String 和类静态变量移动到了 Java 堆</li></ol><h3 id="1-2-堆栈原理"><a href="#1-2-堆栈原理" class="headerlink" title="1.2 堆栈原理"></a>1.2 堆栈原理</h3><p>讲了其中方法区，程序计数器，本地方法栈比较简单，下面深入理解下，堆和栈的概念：<br>(1)堆由年轻代，老年代组成，年轻带占整个堆的1/3，老年代占整个堆的2/3，配比可以调整，年轻代有Eden区Survivor区，配比为8：1：1，new出来的对象一般在Eden区，Eden放满的时候会执行minor gc，回收无用的对象。<br>回收基本原理，从gcroot，找局部变量 静态变量引用了其他的话，就不是垃圾对象，复制到s0，分代年龄会加1，第二次Eden满的时候s0和Eden都会minor gc存活下来的对象存放到s1，分代年龄+1，当分代年龄到15，会被挪到老年代，老年代满的时候，会full gc，回收后还是满的话，就会内存溢出报错<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%A0%86%E7%9A%84%E7%BB%84%E6%88%90.png" alt="堆的组成"></p><p>(2)栈是服务于方法的，当启动一个线程的时候，就会在栈中预先分配出一块空间，当线程执行方法的时候，会在这个预先分配的栈空间中创建一个<br>栈帧的数据结构。栈帧(Stack Frame)是用于支持虚拟机进行方法调用和方法执行的数据结构，是用来存储数据和部分过程结果的数据结构，同时也用来处理动态连接、方法返回值和异常分派。<br>栈帧随着方法调用而创建，随着方法结束而销毁——无论方法正常完成还是异常完成都算作方法结束栈帧由以下部分组成：  </p><ul><li>局部变量表：方法的局部变量和方法参数。main方法的局部变量表中对象变量存放的是堆的地址   </li><li>操作数栈：局部变量的操作数的临时的内存空间   </li><li>动态链接：一个指向运行时常量池的引用，将 class 文件中的符号引用（描述一个方法调用了其他方法或访问成员变量）转为直接引用。符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为静态解析。另一部分将在每次运行期间转化为直接引用，这类转化称为动态连接。  </li><li>方法返回：方法正常退出或抛出异常退出，返回方法被调用的位置<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E6%A0%88%E5%B8%A7.png" alt="栈帧"></li></ul><h3 id="1-3-JVM概览"><a href="#1-3-JVM概览" class="headerlink" title="1.3 JVM概览"></a>1.3 JVM概览</h3><p><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/JVM.png" alt="JVM概览">  </p><h1 id="2-JVM内存参数设置"><a href="#2-JVM内存参数设置" class="headerlink" title="2.JVM内存参数设置"></a>2.JVM内存参数设置</h1><p><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/JVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="JVM总体参数">     </p><ul><li><p>springboot的jvm参数设置格式(Tomcat启动直接加在bin目录下catalina.sh文件里)：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">java -Xms2048M -Xmx2048M -Xmn1024M -Xss512K -XX:MetaspaceSize=256M -XX:MaxMetaspaceSize=256M -jar microservice-eureka-server.jar</span><br><span class="line">-Xss：每个线程的栈大小</span><br></pre></td></tr></table></figure></li><li><p>关于元空间的JVM参数有两个：<br>-XX:MetaspaceSize=N和<br>-XX:MaxMetaspaceSize=N  </p></li><li><p>XX：MaxMetaspaceSize： 设置元空间最大值， 默认是-1， 即不限制， 或者说只受限于本地内存大小   </p></li><li><p>XX：MetaspaceSize： 指定元空间触发Fullgc的初始阈值(元空间无固定初始大小)， 以字节为单位，默认是21M左右，达到该值就会触发full gc进行类型卸载， 同时收集器会对该值进行调整： 如果释放了大量的空间， 就适当降低该值； 如果释放了很少的空间， 那么在不超过-XX：MaxMetaspaceSize（如果设置了的话） 的情况下， 适当提高该值。这个跟早期jdk版本的</p></li><li><p>XX:PermSize参数意思不一样，<br>-XX:PermSize代表永久代的初始容量。<br>由于调整元空间的大小需要Full GC，这是非常昂贵的操作，如果应用在启动的时候发生大量Full GC，通常都是由于永久代或元空间发生<br>了大小调整，基于这种情况，一般建议在JVM参数中将MetaspaceSize和MaxMetaspaceSize设置成一样的值，并设置得比初始值要大，<br>对于8G物理内存的机器来说，一般我会将这两个值都设置为256M。</p></li></ul><p>结论：<br>-Xss设置越小count值越小，说明一个线程栈里能分配的栈帧就越少，但是对JVM整体来说能开启的线程数会更多</p><h3 id="2-1-日均百万级订单交易系统如何设置JVM参数"><a href="#2-1-日均百万级订单交易系统如何设置JVM参数" class="headerlink" title="2.1 日均百万级订单交易系统如何设置JVM参数"></a>2.1 日均百万级订单交易系统如何设置JVM参数</h3><p><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E4%BA%BF%E7%BA%A7%E6%B5%81%E9%87%8FJVM%E5%8F%82%E6%95%B0%E8%AE%BE%E7%BD%AE.png" alt="亿级流量JVM参数调优"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;结论：通过上面这些内容介绍，大家应该对JVM优化有些概念了，就是尽可能让对象都在新生代里分配和回收，尽量别让太多对象频繁进入老年代，避免频繁对老年代进行垃圾回收，同时给系统充足的内存大小，避免新生代频繁的进行垃圾回收。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;前言：为什么要学习JVM？&lt;br&gt;一门语言有可能会过时，但是它的思想是不会过时的，尤其是作为JAVA跨平台的核心实现，JVM的思想值每个程序员得学习&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://aj-web.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>推荐系统理论基础</title>
    <link href="https://aj-web.github.io/2021/08/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/"/>
    <id>https://aj-web.github.io/2021/08/25/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F/</id>
    <published>2021-08-25T03:10:16.447Z</published>
    <updated>2021-08-27T07:47:03.470Z</updated>
    
    <content type="html"><![CDATA[<hr><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;相信大家都在网上买过东西，那么各种各样的商城都会有类似猜你喜欢的推荐，不知道大家觉得这些推荐准嘛？可能准确率会因人而异，但是可以确定是，这种推荐系统对于提高销售额，一定是有帮助的，今天就来了解一下推荐系统</p><span id="more"></span><h1 id="1-推荐系统功能介绍"><a href="#1-推荐系统功能介绍" class="headerlink" title="1. 推荐系统功能介绍"></a>1. 推荐系统功能介绍</h1><h2 id="1-1-推荐系统"><a href="#1-1-推荐系统" class="headerlink" title="1.1 推荐系统"></a>1.1 推荐系统</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;推荐系统是利用电子商务网站向客户提供商品信息和建议，帮助用户决定应该购买什么产品，模拟销售人员帮助客户完成购买过程。个性化推荐是根据用户的兴趣特点和购买行为，向用户推荐用户感兴趣的信息和商品</p><h2 id="1-2-定义"><a href="#1-2-定义" class="headerlink" title="1.2 定义"></a>1.2 定义</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;推荐系统有3个重要的模块：用户建模模块、推荐对象建模模块、推荐算法模块。通用的推荐系统模型流程如图。推荐系统把用户模型中兴趣需求信息和推荐对象模型中的特征信息匹配，同时使用相应的推荐算法进行计算筛选，找到用户可能感兴趣的推荐对象，然后推荐给用户。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E6%8E%A8%E8%8D%90%E7%B3%BB%E7%BB%9F%E5%AE%9A%E4%B9%89%E5%9B%BE.png" alt="推荐系统"></p><h1 id="2-推荐系统实现"><a href="#2-推荐系统实现" class="headerlink" title="2. 推荐系统实现"></a>2. 推荐系统实现</h1><h2 id="2-1-简单推荐系统思路？"><a href="#2-1-简单推荐系统思路？" class="headerlink" title="2.1 简单推荐系统思路？"></a>2.1 简单推荐系统思路？</h2><p>例如：<br>1.把每天打折的物品进行推荐？<br>2.在订单表中找销售量最靠前的产品？<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;上述也是比较简单的实现思路，但是并不智能，不能根据每个人的喜好来推荐，各大主流的购物网也明显不是采用这种方式来实现</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;所以要选择合适的推荐系统，我们需要了解推荐系统的作用：<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;推荐系统要能够根据用户的信息需求，兴趣爱好等，将用户感兴趣的信息、产品等推荐给用户的个性化信息推荐系统。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;站在电商网站的角度，只是从销量或者打折这样单方面进行推荐，这样的推荐系统肯定是起不到吸引客户消费的目的。所以，好的推荐系统必须考虑到用户的喜好以及产品的特点。用户经常浏览以及购买什么物品，购买产品最多的人是年轻人还是老年人？那电商网站怎么知道用户的喜好，以及产品的受众呢？这就必须要基于大量用户和产品的数据，所以本次的推荐系统就是来带大家一起处理，收集，计算这些大量的用户以及产品的数据，通过机器学习的方式，形成一个有价值的推荐系统</p><h2 id="2-2-推荐系统核心理解"><a href="#2-2-推荐系统核心理解" class="headerlink" title="2.2 推荐系统核心理解"></a>2.2 推荐系统核心理解</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;推荐系统在我们实际生活中，可以有很多衍生场景。那这些推荐系统的核心到底是什么呢？其实推荐系统的真正核心可以理解为一个矩阵求解的数学问题。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如，网站向用户推荐商品，往往要基于用户以以往的浏览记录或者评价记录，而这些记录就可以抽象为（userid，productid，score）这样的一个向量结构，score可以是一个任意的数字，比如在这里表示用户的浏览次数，也可以是一个0或1的值，表示用户与商品之间是否建立了关系，比如是否购买过商品。而这样一些数据往往是比较零散的。当我们需要将这些数据整体进行梳理，就会以userid为一列，productid为一行，整理成这样一个矩阵。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E7%94%A8%E6%88%B7%E5%95%86%E5%93%81%E5%90%91%E9%87%8F%E7%9F%A9%E9%98%B5.png" alt="用户商品向量矩阵"></p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;一个向量数据,就代表了矩阵中的一个点，在这个矩阵中，数据通常是比较稀疏的，称为稀疏矩阵，而推荐算法要做的，就是将这些矩阵中的空白点，以某一种方法进行部分填充或者全部填充，每填充一个点，就代表向用户推荐这个产品的一个推荐指数，然后选举推荐指数比较高的产品推荐给客户。</p><h2 id="2-3-推荐系统效果评价"><a href="#2-3-推荐系统效果评价" class="headerlink" title="2.3 推荐系统效果评价"></a>2.3 推荐系统效果评价</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;针对上面想法，当我们有了数据之后，我们就可以把推荐系统这个抽象的理论问题，转换成一个具体的数学问题，但是这个问题并没有标准的答案，我们可以往里面填写任意的数字，即使当我们运用机器学习来预测，不同的模型，算法，也会预测出不同的结果，但是在众多的结果之中，总会有一些结果会更加适合大众的口味，虽然不同的推荐系统没有明确的分数来表示他的好坏，但是，最重他们还是会体现出不同层次的好坏。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;那么为什么会这样呢？从数学的角度来看待这个问题，就是因为我们自己设计的推荐系统没有很好的利用已有的数据，没有从已有数据中”学习”到内在的规律。而好的推荐系统则是通过机器学习很好的挖掘出了已有数据的一些内在规律，这些内在规律可以体现为每个用户的兴趣爱好，每个产品的最佳受众等等很多规律，甚至于很多人类无法描述的规律。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如最经典的啤酒和尿不湿要放在一起售卖的问题，这是一个机器学习中的经典故事，你可以强行做一些解释，但是总是很难接触到本质。所欲，对于推荐系统的评价需要基于非常多的维度进行综合评价。大致可以分为以下几类：</p><ul><li><p>基于常识的评判标准<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;从上面我们已经知道了，推荐系统其实只是一个数字游戏，但是我们的业务不可能是简单的数字游戏。有一些推荐的结果，我们是可以直接从业务上判断是好是坏的，其中坏的推荐的比例，就可以作为对推荐系统一个评判的标准。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;比如，对于天猫，淘宝这类电商网站，给用户推荐他已经购买过的商品，往往就不是一个比较好的结果。但是推荐已经购买过的商品的周边商品，这个结果就比较好。就比如用户购买了一个鼠标，用户再去购买鼠标的概率就比较低，但是如果推荐一个配套的鼠标垫，鼠标贴，用户去购买的可能性就会比较高。<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;对于一个音乐类的内容推荐系统，如果用户是某一个歌星的粉丝，那么再去给他推荐这个歌星的其他的歌或者专辑，意义就不是那么大，因为这些内容用户通常都会主动搜索。再比如对一个新闻类的内容推荐系统，如果推荐给用户的新闻包含了很多”过时”的内容，或者推荐很久之前的帖子，那么显然也不是一个好的推荐</p></li><li><p>基于指标的评判标准<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;通常对于业务系统的评价，还是会回归到业务的本身。所以对于推荐系统最常见的评判标准，还是通过一定的业务指标来衡量。例如常见的PV、UV、用户留存率、转化率等等，通过比对上推荐系统之前和之后的指标数据，来衡量一个推荐系统是不是有效，或者拿推荐系统优化前后的数据进行比较，来看推荐系统的优化是否有效。比如对于猫眼这样的购票系统，最直接的衡量标准就是推荐系统带来的流量和收入的增长<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;另外，对于推荐系统，还有⼀个⾮常重要的指标就是推荐产品的覆盖率，也就是推荐出来的产品应该要越丰富越  好。这是为什么呢？这就涉及到了电商的⼀个根本性的理论模型-“⻓尾经济模型”。商品的交易⾏为，通常都会遵循<br>⼀个普遍性的2-8理论，即80%的利润出⾃于20%的商品。⽐如我们去超市购物，通常也都⽐较喜欢购买最热⻔的， 品牌印象⼒⼤的商品。所以当我们以产品为X轴，产品带来的利润为Y轴，经过整理通常都能得到⼀个这样的正态分布图<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%95%86%E5%93%81%E5%88%A9%E6%B6%A6%E6%AD%A3%E6%80%81%E5%88%86%E5%B8%83.png" alt="商品利润正态分布图"></p></li><li><p>基于机器学习的评判标准<br>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;通常推荐系统需要结合⼤量的业务数据，通过对历史数据的挖掘、分析，归纳出⽤⼾与产品之间的⼀些关系。这些  关系通常过于隐晦，有些是能够进⾏解释的特征，⽐如⽤⼾的爱好、产品的受众特点等。但是往往还有很多隐藏的关系是⽆法⽤简单的常理来解释的。这些关系就要通过机器学习的算法来进⾏深⼊挖掘。最终通过这些分析，所以现在业界普遍的推荐系统都是基于机器学习算法来完成的。⽽每⼀个机器学习的算法，都会有他⾃⼰的评判指标和优化⽅式</p></li></ul><h1 id="3-推荐系统-机器学习基础"><a href="#3-推荐系统-机器学习基础" class="headerlink" title="3 推荐系统-机器学习基础"></a>3 推荐系统-机器学习基础</h1><h2 id="3-1-机器学习的应⽤领域："><a href="#3-1-机器学习的应⽤领域：" class="headerlink" title="3.1 机器学习的应⽤领域："></a>3.1 机器学习的应⽤领域：</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;机器学习的应⽤领域是⾮常多的，⼤体上，可以分为三个主要的⽅向：</p><ol><li>传统预测：主要⽤在数据挖掘，预测领域。典型的应⽤场景： 店铺销量预测、房价预测、垃圾邮件安全监测等。包括我们这个课程的推荐系统，其实⼤体上也可以分到这⼀类。当然，这也并不是绝对的。基于神经⽹络 的推荐系统也是有很多落地实现的</li><li>图像识别：典型应⽤场景：⾃动驾驶、⼈脸识别、涉⻩图⽚视频过滤等</li><li>⾃然语⾔处理：典型应⽤场景：⽂本分类、聊天机器⼈、智能客服、⽂本翻译等。其实我们能感觉到，早期的  百度中英⽂翻译就⾮常难懂，语法⾮常混乱。但是现在百度中英⽂翻译就相当⼈性化了，语法也⾮常⾃然。这 其中就有深度学习参与其中。</li></ol><h2 id="3-2-机器学习数据形式"><a href="#3-2-机器学习数据形式" class="headerlink" title="3.2 机器学习数据形式"></a>3.2 机器学习数据形式</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;机器学习有三个关键词： 数据，模型，预测。机器学习强调从历史数据中⾃动学习，对数据之间的规律进⾏归<br>纳，形成模型，然后⽤模型来对实际问题进⾏预测。这个过程跟⼈类理解⼀个事物的过程是很类似的。回想⼀下，⼈类去分辨猫和狗、或者预测房价未来的⾛势，其实也是这样⼀个过程。⼈需要从⼤量的⽇常⽣活经验中归纳出⼀系列  的规律，然后在⾯临具体问题时，就可以从众多规律中找到最优化的规律，来解决⽇常问题。</p><h2 id="3-3-机器学习的分类"><a href="#3-3-机器学习的分类" class="headerlink" title="3.3 机器学习的分类"></a>3.3 机器学习的分类</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;机器学习涉及到⾮常多的数学算法。对这些数学算法，通常会根据⽬标值的类型进⾏简单分类。</p><ol><li>分类算法： 这⼀类问题的⽬标值是有限的⼏个离散值。例如我们对动物进⾏分类。常⽤的算法有： k近邻算法、⻉叶斯算法、决策树与随机森林、逻辑回归等。</li><li>回归算法： 这⼀类问题的⽬标值是⼀组连续值。例如对房价的预测。常⽤的算法有：线性回归、岭回归等。</li><li>⽆监督学习：这⼀类问题没有⽬标值。也就是说，没有⼀个固定的⽬标去监督机器学习的过程。例如我们常说 的⼈以类聚，物以群分。我们通常会需要将所有客⼾区分成⼀个个具有相似特征的客⼾群，但是我们也不知道 要把客⼾分成哪些群⽐较合适。这个时候，就可以⽤⽆监督学习，让机器学习去找出最具有区分度的划分⽅式。常⽤的算法有 k-Means分类算法。</li></ol><p>与⽆监督学习对应的，分类算法和回归算法都是有⽬标值，也就是有具体⽬标的机器学习算法，他们就统称为监督学习</p><h2 id="3-4-怎么获取数据集？"><a href="#3-4-怎么获取数据集？" class="headerlink" title="3.4 怎么获取数据集？"></a>3.4 怎么获取数据集？</h2><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;在实际业务中，这些有⽤的数据集成本巨⼤，甚⾄可能包含了很多核⼼的商业机密。那在学习阶段，我们要怎么去  获得有价值的数据集呢？主要还是通过直接使⽤别⼈维护好的数据集。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">⾏业内有很多科研⼈员都维护了很多质量⾮常⾼的开源数据集。例如python的sklearn框架就集成了⼀部分常⽤的数据集。</span><br><span class="line"></span><br><span class="line">参⻅pycharm中的Demo: sklearn_datasets.py，加载sklearn本地的Iris鸢尾花数据集，还有也加载了</span><br><span class="line">Boston波斯顿房价数据集。这两个数据集是机器学习领域最为经典的数据集。Iris就是分类问题数据集， Boston则是回归问题数据集。</span><br><span class="line"></span><br><span class="line">⽽在java领域，可以使⽤Spark的mllib包来做机器学习。也可以将这些csv⽂件读到spark当中。参⻅SparkDemo中的</span><br><span class="line">LoadDataDemo。</span><br></pre></td></tr></table></figure><p>UCI： <a href="http://archive.ics.uci.edu/ml/">http://archive.ics.uci.edu/ml/</a>  这个⽹站上维护了很多经典的数据集。<br>kaggle： <a href="https://www.kaggle.com/">https://www.kaggle.com/</a>  ⼀个综合性的机器学习竞赛平台。上⾯会开放很多数据集，开展很多机器学习的竞赛。有很多都是⼀些公司⾃⼰处理不了的实际数据，数据集的质量通常都是⽐较⾼的。同时也有很多别⼈分享  的基础教程以及算法分享，也都是⾮常不错的学习资料。</p><p>&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;&emsp;关于机器学习，有⼀本⾮常经典的⼊⻔资料，就是周志华的《机器学习》，俗称为西⽠书。因封⾯有很多西⽠，并且全篇很     多问题都从西⽠谈起⽽得名。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E8%A5%BF%E7%93%9C%E4%B9%A6.png" alt="西瓜书"></p><p>⽽关于深度学习，也有⼀本⾮常经典的资料，名字就叫做《Deep leaning》，深度学习。俗称为花书，因封⾯有⾮常多的花<br>⽽得名。<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E8%8A%B1%E4%B9%A6.jpg" alt="花书"></p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;p&gt;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;&amp;emsp;相信大家都在网上买过东西，那么各种各样的商城都会有类似猜你喜欢的推荐，不知道大家觉得这些推荐准嘛？可能准确率会因人而异，但是可以确定是，这种推荐系统对于提高销售额，一定是有帮助的，今天就来了解一下推荐系统&lt;/p&gt;</summary>
    
    
    
    
    <category term="机器学习" scheme="https://aj-web.github.io/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>JVM类加载机制解析</title>
    <link href="https://aj-web.github.io/2021/08/25/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>https://aj-web.github.io/2021/08/25/JVM%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/</id>
    <published>2021-08-25T03:07:14.024Z</published>
    <updated>2021-08-25T03:07:14.024Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="1-1类加载机制"><a href="#1-1类加载机制" class="headerlink" title="1.1类加载机制"></a>1.1类加载机制</h1><p>类加载步骤：加载 &gt; &gt; 验证 &gt; &gt; 准备 &gt; &gt; 解析 &gt; &gt; 初始化 &gt; &gt; 使用 &gt; &gt; 卸载</p><span id="more"></span><ul><li>加载：在硬盘上查找并通过IO读入字节码文件，使用到类时才会加载，例如调用类的main()方法，new对象等等，在加载阶段会在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口</li><li>验证：校验字节码文件的正确性</li><li>准备：给类的静态变量（类变量）分配内存，并赋予默认值</li><li>解析：将符号引用替换为直接引用，该阶段会把一些静态方法(符号引用，比如main()方法)替换为指向数据所存内存的指针或句柄等(直接引用)，这是所谓的静态链接过程(类加载期间完成)，动态链接是在程序运行期间完成的将符号引用替换为直接引用</li><li>初始化:对类的静态变量初始化为指定的值，执行静态代码块</li></ul><blockquote><p>以上是类加载的5个阶段，那么除了类加载的5个阶段，还有：<code>使用</code>，<code>卸载</code>两个阶段<br>也就是类的生命周期=类加载+<code>使用</code>+<code>卸载</code></p></blockquote><h3 id="1-1类加载机制拓展理解"><a href="#1-1类加载机制拓展理解" class="headerlink" title="1.1类加载机制拓展理解"></a>1.1类加载机制拓展理解</h3><p>上面的基本概念是各网站都能搜到的，我们再结合自己进行拓展，理解一下：</p><p><strong>加载：</strong></p><ol><li>加载会通过限定名(可以简单理解为类名)获取到类的二进制字节流</li><li>将二进制字节文件的数据放到方法区，然后在堆中生产一个代表这个类的java.lang.Class对象，Class 对象封装了类在方法区内的数据结构，并且向开发者提供了访问方法区内的数据结构的接口</li></ol><p>所以我们可以认为，开发中用的是Class对象，但是当我们想要这个类的某些信息的时候，我们需要通过这个Class对象，到方法区中去找。例如类的<code>元数据</code>和<code>方法信息(继承信息、成员变量、静态变量、成员方法、构造函数)</code>。那么如何找到，就涉及到对象头中的一个Klass point:类型指针，通过类型指针来找到方法区中的元数据等。</p><p><strong>验证：</strong></p><ol><li>文件格式验证：（class文件来源不唯一(自己也可以手写)，有可能格式正确损坏虚拟机）</li><li>元数据验证：（是否符合类的定义规范，例如是否继承java.lang.Object）</li><li>字节码验证：（类中方法的控制流是否合法）</li><li>符号引用验证：（转换为直接引用动作是否合法）</li></ol><p><strong>准备：</strong></p><ol><li>为类变量分配内存，赋予默认值</li><li>实例变量会在创建对象过程中一起被分配，详情看下一章</li></ol><p><strong>解析：</strong></p><ol><li>将符号引用替换为直接引用</li><li>符号引用（Symbolic References）：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用（Direct References）：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。如果有了直接引用，那么引用的目标一定是已经存在于内存中。</li></ol><p>上面我们已经知道了，类的元数据和方法信息是存在方法区的，那么方法区可能存在符号引用，这个时候就需要进行解析了，通常有：1.类或接口的解析2.字段解析3.类方法解析4.接口方法解析，解析之后，针对我们解析到的内容，可能还需要进行上面的加载验证准备步骤</p><p><strong>初始化</strong></p><ol><li>为类变量赋予默认值</li><li>执行静态代码块，静态方法</li><li>执行构造方法</li></ol><p>执行顺序</p><ul><li>先加载父类的静态代码块和静态变量 这两个加载的顺序与代码顺序有关</li><li>加载子类的静态代码块和静态变量  加载的顺序也与位置有关</li><li>加载父类的变量和语句块</li><li>加载父类的构造方法</li><li>加载子类的变量和语句块</li><li>加载子类的构造方法</li></ul><h1 id="2-虚拟机的内存分配情况"><a href="#2-虚拟机的内存分配情况" class="headerlink" title="2.虚拟机的内存分配情况"></a>2.虚拟机的内存分配情况</h1><ol><li>虚拟机栈：每个class类对应一个虚拟机栈帧（组成：局部变量表、操作数栈、返回地址、动态链接），类私有</li><li>堆：存放对象</li><li>方法区：存放类信息、常量、类变量、即时编译器编译后的代码</li><li>常量池：是方法区的一部分，主要有字面量（常量和字符串）和符号引用（类和接口的符号引用、字段的名称和描述的符号引用、方法的名称和描述的符号引用）</li></ol><h1 id="3-类加载器和双亲委派机制"><a href="#3-类加载器和双亲委派机制" class="headerlink" title="3.类加载器和双亲委派机制"></a>3.类加载器和双亲委派机制</h1><h3 id="3-1类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器"><a href="#3-1类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器" class="headerlink" title="3.1类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器"></a>3.1类加载过程主要是通过类加载器来实现的，Java里有如下几种类加载器</h3><ol><li>引导类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的核心类库，比如rt.jar、charsets.jar等</li><li>扩展类加载器：负责加载支撑JVM运行的位于JRE的lib目录下的ext扩展目录中的JAR类包</li><li>应用程序类加载器：负责加载ClassPath路径下的类包，主要就是加载你自己写的那些类</li><li>自定义加载器：负责加载用户自定义路径下的类包</li></ol><h3 id="3-2类加载器初始化过程："><a href="#3-2类加载器初始化过程：" class="headerlink" title="3.2类加载器初始化过程："></a>3.2类加载器初始化过程：</h3><p>参见类运行加载全过程图可知其中会创建JVM启动器实例sun.misc.Launcher。<br>在Launcher构造方法内部，其创建了两个类加载器，分别是sun.misc.Launcher.ExtClassLoader(扩展类加载器)和sun.misc.Launcher.AppClassLoader(应用类加载器)。<br>JVM默认使用Launcher的getClassLoader()方法返回的类加载器AppClassLoader的实例加载我们的应用程序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">//Launcher的构造方法</span><br><span class="line">public Launcher() &#123;</span><br><span class="line">    Launcher.ExtClassLoader var1;</span><br><span class="line">    try &#123;</span><br><span class="line">        //构造扩展类加载器，在构造的过程中将其父加载器设置为null</span><br><span class="line">        var1 = Launcher.ExtClassLoader.getExtClassLoader();</span><br><span class="line">    &#125; catch (IOException var10) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create extension class loader&quot;, var10);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        //构造应用类加载器，在构造的过程中将其父加载器设置为ExtClassLoader，</span><br><span class="line">        //Launcher的loader属性值是AppClassLoader，我们一般都是用这个类加载器来加载我们自己写的应用程序</span><br><span class="line">        this.loader = Launcher.AppClassLoader.getAppClassLoader(var1);</span><br><span class="line">    &#125; catch (IOException var9) &#123;</span><br><span class="line">        throw new InternalError(&quot;Could not create application class loader&quot;, var9);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Thread.currentThread().setContextClassLoader(this.loader);</span><br><span class="line">    String var2 = System.getProperty(&quot;java.security.manager&quot;);</span><br><span class="line">    。。。 。。。 //省略一些不需关注代码</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3双亲委派机制"><a href="#3-3双亲委派机制" class="headerlink" title="3.3双亲委派机制"></a>3.3双亲委派机制</h3><p>JVM类加载器是有亲子层级结构的，如下图<br><img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE.png" alt="双亲委派机制"></p><p>这里类加载其实就有一个双亲委派机制，加载某个类时会先委托父加载器寻找目标类，找不到再委托上层父加载器加载，如果所有父加载器在自己的加载类路径下都找不到目标类，则在自己的类加载路径中查找并载入目标类。<br>比如我们的Math类，最先会找应用程序类加载器加载，应用程序类加载器会先委托扩展类加载器加载，扩展类加载器再委托引导类加载器，顶层引导类加载器在自己的类加载路径里找了半天没找到Math类，则向下退回加载Math类的请求，扩展类加载器收到回复就自己加载，在自己的类加载路径里找了半天也没找到Math类，又向下退回Math类的加载请求给应用程序类加载器，应用程序类加载器于是在自己的类加载路径里找Math类，结果找到了就自己加载了。。<br>双亲委派机制说简单点就是，先找父亲加载，不行再由儿子自己加载</p><h3 id="3-4双亲委派机制的好处"><a href="#3-4双亲委派机制的好处" class="headerlink" title="3.4双亲委派机制的好处"></a>3.4双亲委派机制的好处</h3><ul><li>沙箱安全机制：自己写的java.lang.String.class类不会被加载，这样便可以防止核心API库被随意篡改</li><li>避免类的重复加载：当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次，保证被加载类的唯一性</li></ul><h3 id="3-5类加载源码分析"><a href="#3-5类加载源码分析" class="headerlink" title="3.5类加载源码分析"></a>3.5类加载源码分析</h3><p>我们来看下应用程序类加载器AppClassLoader加载类的双亲委派机制源码，AppClassLoader的loadClass方法最终会调用其父类ClassLoader的loadClass方法，该方法的大体逻辑如下：<br>首先，检查一下指定名称的类是否已经加载过，如果加载过了，就不需要再加载，直接返回。<br>如果此类没有加载过，那么，再判断一下是否有父加载器；如果有父加载器，则由父加载器加载（即调用parent.loadClass(name, false);）.或者是调用bootstrap类加载器来加载。<br>如果父加载器及bootstrap类加载器都没有找到指定的类，那么调用当前类加载器的findClass方法来完成类加载。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">//ClassLoader的loadClass方法，里面实现了双亲委派机制</span><br><span class="line">protected Class&lt;?&gt; loadClass(String name, boolean resolve)</span><br><span class="line">    throws ClassNotFoundException</span><br><span class="line">&#123;</span><br><span class="line">    synchronized (getClassLoadingLock(name)) &#123;</span><br><span class="line">        // 检查当前类加载器是否已经加载了该类</span><br><span class="line">        Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">        if (c == null) &#123;</span><br><span class="line">            long t0 = System.nanoTime();</span><br><span class="line">            try &#123;</span><br><span class="line">                if (parent != null) &#123;  //如果当前加载器父加载器不为空则委托父加载器加载该类</span><br><span class="line">                    c = parent.loadClass(name, false);</span><br><span class="line">                &#125; else &#123;  //如果当前加载器父加载器为空则委托引导类加载器加载该类</span><br><span class="line">                    c = findBootstrapClassOrNull(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; catch (ClassNotFoundException e) &#123;</span><br><span class="line">                // ClassNotFoundException thrown if class not found</span><br><span class="line">                // from the non-null parent class loader</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (c == null) &#123;</span><br><span class="line">                // If still not found, then invoke findClass in order</span><br><span class="line">                // to find the class.</span><br><span class="line">                long t1 = System.nanoTime();</span><br><span class="line">                //都会调用URLClassLoader的findClass方法在加载器的类路径里查找并加载该类</span><br><span class="line">                c = findClass(name);</span><br><span class="line"></span><br><span class="line">                // this is the defining class loader; record the stats</span><br><span class="line">                sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (resolve) &#123;  //不会执行</span><br><span class="line">            resolveClass(c);</span><br><span class="line">        &#125;</span><br><span class="line">        return c;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-6全盘负责委托机制"><a href="#3-6全盘负责委托机制" class="headerlink" title="3.6全盘负责委托机制"></a>3.6全盘负责委托机制</h3><p>“全盘负责”是指当一个ClassLoder装载一个类时，除非显示的使用另外一个ClassLoder，该类所依赖及引用的类也由这个ClassLoder载入。</p>]]></content>
    
    
    <summary type="html">&lt;hr&gt;
&lt;h1 id=&quot;1-1类加载机制&quot;&gt;&lt;a href=&quot;#1-1类加载机制&quot; class=&quot;headerlink&quot; title=&quot;1.1类加载机制&quot;&gt;&lt;/a&gt;1.1类加载机制&lt;/h1&gt;&lt;p&gt;类加载步骤：加载 &amp;gt; &amp;gt; 验证 &amp;gt; &amp;gt; 准备 &amp;gt; &amp;gt; 解析 &amp;gt; &amp;gt; 初始化 &amp;gt; &amp;gt; 使用 &amp;gt; &amp;gt; 卸载&lt;/p&gt;</summary>
    
    
    
    
    <category term="JVM" scheme="https://aj-web.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>数据结构与算法入门</title>
    <link href="https://aj-web.github.io/2021/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/"/>
    <id>https://aj-web.github.io/2021/07/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E5%85%A5%E9%97%A8/</id>
    <published>2021-07-31T11:33:27.000Z</published>
    <updated>2021-08-13T01:47:27.709Z</updated>
    
    <content type="html"><![CDATA[<h1 id="1-为什么要学习数据结构与算法"><a href="#1-为什么要学习数据结构与算法" class="headerlink" title="1.为什么要学习数据结构与算法"></a>1.为什么要学习数据结构与算法</h1><ol><li>面试必问</li><li>加深对集合类的理解和使用</li><li>架构师必备，写出框架级的代码；API，写出开源级代码，同时应对中年危机</li><li>提升自己的能力，不被行业淘汰：H5，小程序。红黑树，几十年的时间。B+Tree<span id="more"></span></li></ol><h1 id="2-什么是数据结构与算法"><a href="#2-什么是数据结构与算法" class="headerlink" title="2.什么是数据结构与算法"></a>2.什么是数据结构与算法</h1><ol><li>数据存储于内存时，决定了数据顺序和位置关系的便是数据结构</li><li>算法就是解决问题的最优解</li></ol><h1 id="3-算法的特点"><a href="#3-算法的特点" class="headerlink" title="3.算法的特点"></a>3.算法的特点</h1><ol><li>五个特征：有穷性、确定性、可行性、有输入、有输出</li><li>设计原则：正确性、可读性、健壮性、写出代码很少有bug，而且系统比较稳定</li></ol><h1 id="4-时间复杂度与空间复杂度"><a href="#4-时间复杂度与空间复杂度" class="headerlink" title="4.时间复杂度与空间复杂度"></a>4.时间复杂度与空间复杂度</h1><ol><li>时间复杂度计算意义：程序运行的时间</li><li> 时间复杂度表示方法：  </li></ol><ul><li>常数：O(1) 1表示是常数，所有能确定的数字我们都用O（1），O(1000)=&gt;o(1)</li><li>对数：O(logn),O(nlogn)</li><li>线性：O(n)</li><li>线性对数：O(nlogn)</li><li>平方：O(n^2)</li><li>N次方：O(n^n)</li></ul><ol start="3"><li>时间复杂度如何分析：<br>（1）找for while 递归。而且要找循环量最大的那一段<br>（2）同级循环怎么计算</li></ol><ol start="4"><li>如何找时间复杂度：</li></ol><ul><li>找到有循环的地方</li><li>找有网络请求（RPC，远程调用，分布式，数据库请求）的地方。就是测试时间：log打印，计算平均时间。</li></ul><p>(<img src="https://raw.githubusercontent.com/aj-web/picturebed/master/%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6%E6%9B%B2%E7%BA%BF%E5%9B%BE.png" alt="时间复杂度">)</p><p>5.从图我们可以的出最终的结论：O(1)&gt;O(logn)&gt;O(n)&gt;O(nlogn)&gt;O(n^2)&gt;O(n^x)，从O(1)&gt;O(logn)&gt;O(n)&gt;O(nlogn)，这些效果都是很好的。几乎优化的空间不是很大，但是后面两个时间复杂度是尽可能的优化下，我们优化最终的目标就是往O(1)的方向接近。</p><hr><h2 id="例题：判断一个数是否是2的N次方"><a href="#例题：判断一个数是否是2的N次方" class="headerlink" title="例题：判断一个数是否是2的N次方"></a>例题：判断一个数是否是2的N次方</h2><ol start="0"><li>传统思路：对这个数取余 n%2==0?,如果等于0就是2的N次方</li><li>优化思路：采取2进制进行与计算,<br>原理：1–&gt;01   2–&gt;10   3–&gt;011  4–&gt;100<br>那么我们可以发现： 3&amp;2 !=0 4&amp;3==0<br>也就是，if(n&amp;(n-1)==0),那么n就是2的次方数</li></ol>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;1-为什么要学习数据结构与算法&quot;&gt;&lt;a href=&quot;#1-为什么要学习数据结构与算法&quot; class=&quot;headerlink&quot; title=&quot;1.为什么要学习数据结构与算法&quot;&gt;&lt;/a&gt;1.为什么要学习数据结构与算法&lt;/h1&gt;&lt;ol&gt;
&lt;li&gt;面试必问&lt;/li&gt;
&lt;li&gt;加深对集合类的理解和使用&lt;/li&gt;
&lt;li&gt;架构师必备，写出框架级的代码；API，写出开源级代码，同时应对中年危机&lt;/li&gt;
&lt;li&gt;提升自己的能力，不被行业淘汰：H5，小程序。红黑树，几十年的时间。B+Tree</summary>
    
    
    
    
  </entry>
  
</feed>
